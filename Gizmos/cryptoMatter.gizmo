Gizmo {
 name CryptoMatter
 addUserKnob {20 timo l Timo.ink}
 addUserKnob {22 cryptoFunction l INVISIBLE +INVISIBLE T "#\n# CryptoMatter\n# By Timothy Halim\n# mail@timo.ink\n#\n# Created for Fashion Show Project by MainFrame / RainMaker\n#\n# You are allowed to edit and use this script\n# but please put credit for me and inform me about it.\n# Also please don't distribute any part of this script\n# outside of Infinite Studios and Rainmaker Studios without my permission\n# Thanks, have a good day\n#\n# TODO:\n# 1. Auto refresh on cryptomatte change input\n# 2. Restore selection after check/uncheck multiple selection\n# 3. Optimize on branch check/uncheck\n# 4. On screen pick Right click disable pick\n# 5. Fix pick and unpick didn't work if the coordinate didn't change\n# 6. Preview, edit and remove created matte\n#\n\ntry:\n    from PySide2.QtGui import *\n    from PySide2.QtCore import *\n    from PySide2.QtWidgets import *\nexcept:\n    from PySide.QtGui import *\n    from PySide.QtCore import *\n\nimport nuke\n\nimport cryptomatte_utilities as cu\nimport struct\n\ntry:\n    if launched == 1:\n        pass\nexcept:\n    print (\"Init CryptoMatter\")\n\n    global nukeApp\n    nukeApp = QApplication.activeWindow()\n\n    class cryptoInfo(object):\n        def __init__(self, node):\n            self.node = node\n            self.cryptoNode = node\n            self.data = \{\}\n            self.tree = \{\}\n            self.getCryptomatteInfo()\n            self.buildHierarchy()\n\n        def getCryptomatteInfo(self):\n            if self.cryptoNode and self.cryptoNode.metadata():\n                for k, v in self.cryptoNode.metadata().iteritems():\n                    if \"exr/cryptomatte/\" in k and \"/name\" in k:\n                        id = k.replace(\"exr/cryptomatte/\", \"\").replace(\"/name\", \"\")\n                        if not id in self.data.keys():\n                            self.data\[id] = \{\"name\": None, \"object\": \[]\}\n\n                        self.data\[id]\[\"name\"] = v\n                    elif \"exr/cryptomatte/\" in k and \"/manifest\" in k:\n                        id = k.replace(\"exr/cryptomatte/\", \"\").replace(\"/manifest\", \"\")\n                        if not id in self.data.keys():\n                            self.data\[id] = \{\"name\": None, \"object\": \[]\}\n                        obj = eval(v)\n                        objData = \{\}\n                        for k in obj.keys():\n                            tempData = self.getId(k, obj\[k])\n                            objData\[tempData\[0]] = tempData\[1]\n                        self.data\[id]\[\"object\"] = objData\n\n        def getId(self, name, value):\n            unpacker = struct.Struct(\"=f\")\n            packer = struct.Struct(\"=I\")\n            packed = packer.pack(int(value, 16))\n            packed = packed = \"\\0\" * (4 - len(packed)) + packed\n            id_float = unpacker.unpack(packed)\[0]\n            name_str = name.encode(\"utf8\")\n            return \[name_str, id_float]\n\n        def attach(self, branch, trunk, fullpath, id):\n            parts = branch.split(\":\", 1)\n            if len(parts) == 1:  # branch is a file\n                if isinstance(trunk, list):\n                    trunk.append(\{parts\[0]: \[fullpath, self.data\[id]\[\"object\"]\[fullpath]]\})\n                elif isinstance(trunk, dict):\n                    trunk\[parts\[0]] = \[]\n\n            else:\n                node, others = parts\n                if node not in trunk:\n                    if len(others.split(\":\")) > 1:\n                        trunk\[node] = \{\}\n                    else:\n                        trunk\[node] = \[]\n                self.attach(others, trunk\[node], fullpath, id)\n\n        def buildHierarchy(self):\n            for k in self.data.keys():\n                self.tree\[self.data\[k]\[\"name\"]] = \{\}\n                shapes = self.data\[k]\[\"object\"].keys()\n\n                if shapes:\n                    for shape in sorted(shapes):\n                        shapeShn = shape.split(\"|\")\[-1] if \"|\" in shape else shape.split(\"/\")\[\n                            -1] if \"/\" in shape else shape\n                        self.attach(shapeShn, self.tree\[self.data\[k]\[\"name\"]], str(shape), k)\n\n        def buildCryptoExpression(self, items, channel):\n            channels = \[channel + \"00\", channel + \"01\"]\n            ID_list = \[]\n            for item in items:\n                if item.startswith(\"<\") and item.endswith(\">\"):\n                    numstr = item\[1:-1]\n                    if cu._is_number(numstr):\n                        ID_list.append(single_precision(float(numstr)))\n                else:\n                    ID_list.append(cu.mm3hash_float(item))\n\n            expression = cu._build_extraction_expression(channels, ID_list)\n            return expression\n\n        def getName(self, posX, posY, channel):\n            channels = \[channel + \"00\", channel + \"01\"]\n            id = \[k for k in self.data.keys() if self.data\[k]\[\"name\"] == channel]\[0]\n            for c in channels:\n                for sub_channel in \[\".red\", \".blue\"]:\n                    selectedId = self.node.sample(c + sub_channel, posX, posY)\n                    if selectedId in self.data\[id]\[\"object\"].values():\n                        return self.data\[id]\[\"object\"].keys()\[self.data\[id]\[\"object\"].values().index(selectedId)]\n\n\n    class cryptoList(QWidget):\n        def __init__(self, node):\n            super(cryptoList, self).__init__()\n            self.node = node\n\n            self.storedChannel = self.node.knob(\"channel\").getValue()\n            self.storedSearch = self.node.knob(\"search\").getValue()\n            self.storedName = self.node.knob(\"matte\").getValue()\n            self.storedList = eval(self.node.knob(\"store\").getValue())\n            self.pickPosition = self.getCoordinate()\n            self.ctrlPress = False\n            self.altPress = False\n            self.pickState = False\n            self.initUI()\n            self.initCrypto()\n            self.refreshUI()\n            self.pickScreen()\n\n        def initCrypto(self):\n            self.cryptoInfo = cryptoInfo(self.node.input(1))\n\n            self.layers = \[self.cryptoInfo.data\[k]\[\"name\"] for k in self.cryptoInfo.data.keys()]\n            self.layers.sort()\n            self.leaves = \[]\n            self.currentLayer = self.storedChannel if self.storedChannel in self.layers else self.layers\[0] if self.layers else None\n\n        def initUI(self):\n            self.title = QLabel(\"CryptoMatter\")\n            self.title.setText(\"<a href=\\\"https://timo.ink\\\" style=\\\"color: white;\\\">CryptoMatter</a>\")\n            self.title.setAlignment(Qt.AlignCenter)\n            self.title.setFont(QFont(\"Comfortaa\", 20, QFont.Bold))\n            self.title.setTextInteractionFlags(Qt.TextBrowserInteraction)\n            self.title.setOpenExternalLinks(True)\n            self.title.setToolTip(\"<b>CryptoMatter</b><br>by Timothy Halim<br>https://timo.ink\")\n\n            self.credits = QLabel(\"by Timothy Halim\")\n            self.credits.setText(\"<a href=\\\"https://timo.ink\\\" style=\\\"color: white;text-decoration:none;\\\">by Timothy Halim</a>\")\n            self.credits.setAlignment(Qt.AlignCenter)\n            self.credits.setFont(QFont(\"Comfortaa\", 10, QFont.Bold))\n            self.credits.setTextInteractionFlags(Qt.TextBrowserInteraction)\n            self.credits.setOpenExternalLinks(True)\n            self.credits.setToolTip(\"<b>CryptoMatter</b><br>by Timothy Halim<br>https://timo.ink\")\n\n            self.channelLayout = QHBoxLayout()\n\n            self.channelList = QComboBox()\n            self.channelList.setToolTip(\"Cryptomatte Channel\")\n            self.channelList.currentIndexChanged.connect(self.changeLayer)\n\n            self.refreshBtn = QPushButton(\"Refresh\")\n            self.refreshBtn.setMaximumWidth(80)\n            self.refreshBtn.setMinimumWidth(80)\n            self.refreshBtn.setToolTip(\"Refresh Cryptomatte List\")\n            self.refreshBtn.clicked.connect(self.updateCryptoInfo)\n\n            for c in \[self.channelList, self.refreshBtn]:\n                self.channelLayout.addWidget(c)\n\n            self.filterLayout = QHBoxLayout()\n\n            self.filter = QLineEdit(\"\")\n            self.filter.setToolTip(\"Node list filter\")\n            self.filter.setPlaceholderText(\"Search\")\n            self.filter.textChanged.connect(self.filterTree)\n\n            self.pick = QPushButton(\"Pick\")\n            self.pick.setMaximumWidth(80)\n            self.pick.setMinimumWidth(80)\n            self.pick.setCheckable(True)\n            self.pick.setToolTip(\"Pick cryptomatte on screen<br><b>Ctrl + Click</b> to Add<br><b>Ctrl + Alt + Click</b> to Remove\")\n            self.pick.clicked.connect(self.pickScreen)\n\n            for o in \[self.filter, self.pick]:\n                self.filterLayout.addWidget(o)\n\n            # Toggle and filter\n            self.toggleLayout = QHBoxLayout()\n            self.selectAll = QPushButton(\"All\")\n            self.selectAll.setToolTip(\"Check all visible node\")\n            self.selectAll.clicked.connect(lambda: self.toggle(\"All\"))\n            self.selectNone = QPushButton(\"None\")\n            self.selectNone.setToolTip(\"Uncheck all visible node\")\n            self.selectNone.clicked.connect(lambda: self.toggle(\"None\"))\n            self.selectInv = QPushButton(\"Invert\")\n            self.selectInv.setToolTip(\"Invert all visible node check state\")\n            self.selectInv.clicked.connect(lambda: self.toggle(\"Invert\"))\n            for o in \[self.selectAll, self.selectNone, self.selectInv]:\n                self.toggleLayout.addWidget(o)\n\n            # Tree\n            self.treeWidget = QTreeWidget()\n            self.treeWidget.setItemsExpandable(True)\n            self.treeWidget.setAnimated(True)\n            self.treeWidget.setColumnCount(1)\n            self.treeWidget.setSelectionMode(QAbstractItemView.ExtendedSelection)\n            self.treeWidget.setHeaderLabels(\[\"Cryptomatte Node List\"])\n            self.treeLayout = QGridLayout()\n            self.treeLayout.addWidget(self.treeWidget)\n            # layout\n\n            self.matteName = QLineEdit(\"\")\n            self.matteName.setToolTip(\"Matte Name\")\n            self.matteName.setPlaceholderText(\"Matte Name\")\n            self.matteName.textChanged.connect(self.storeName)\n\n            self.createBtn = QPushButton(\"Create Matte\")\n            self.createBtn.setToolTip(\"Create Matte\")\n            self.createBtn.clicked.connect(self.createBtnClicked)\n\n            self.mainLayout = QVBoxLayout()\n\n            self.mainLayout.addWidget(self.title)\n            self.mainLayout.addWidget(self.credits)\n            self.mainLayout.addLayout(self.channelLayout)\n            self.mainLayout.addLayout(self.filterLayout)\n            self.mainLayout.addLayout(self.toggleLayout)\n            self.mainLayout.addLayout(self.treeLayout)\n            self.mainLayout.addWidget(self.matteName)\n            self.mainLayout.addWidget(self.createBtn)\n            self.setLayout(self.mainLayout)\n            self.setToolTip(\"<b>CryptoMatter</b><br>by Timothy Halim<br>https://timo.ink\")\n            self.setStyleSheet(\"\"\"\n                QToolTip \{\n                     border: 1px solid white;\n                     color: white;\n                     padding: 2px;\n                     border-radius: 10px;\n                \}\n                QPushButton:checked \{ background-color: #f7931e; color: white; \} \n            \"\"\")\n\n\n        def refreshUI(self):\n            self.channelList.clear()\n            self.channelList.addItems(self.layers)\n            if self.currentLayer:\n                self.channelList.setCurrentIndex(self.layers.index(self.currentLayer))\n                self.node.node(\"NoInput\").knob(\"in\").setValue(str(self.currentLayer))\n            self.filter.setText(self.storedSearch)\n            self.matteName.setText(self.storedName)\n            self.fillTree()\n\n        def updateCryptoInfo(self):\n            self.initCrypto()\n            self.refreshUI()\n\n        def changeLayer(self):\n            self.currentLayer = self.layers\[self.channelList.currentIndex()]\n            self.node.knob(\"channel\").setValue(str(self.currentLayer))\n            self.node.node(\"NoInput\").knob(\"in\").setValue(str(self.currentLayer))\n            self.fillTree()\n\n        def buildBranch(self, tree, parent, indent=0):\n            for key, value in sorted(tree.iteritems()):\n                branch = QTreeWidgetItem(parent)\n                branch.setText(0, str(key))\n                branch.setFlags(branch.flags() | Qt.ItemIsTristate | Qt.ItemIsUserCheckable)\n                branch.setCheckState(0, Qt.Unchecked)\n                self.treeWidget.expandItem(branch)\n                if value:\n                    if isinstance(value, dict):\n                        self.buildBranch(value, branch, indent + 1)\n                    else:\n                        for oData in sorted(value):\n                            leaf = QTreeWidgetItem(branch)\n                            leaf.setFlags(leaf.flags() | Qt.ItemIsUserCheckable)\n                            leaf.setCheckState(0, Qt.Unchecked)\n                            leaf.setText(0, str(oData.keys()\[0]))\n                            leaf.setToolTip(0, str(oData.values()\[0]\[0]))\n\n                            if str(oData.values()\[0]\[0]) in self.storedList:\n                                leaf.setCheckState(0, Qt.Checked)\n                            else:\n                                leaf.setCheckState(0, Qt.Unchecked)\n\n                            self.leaves.append(leaf)\n                else:\n                    branch.setToolTip(0, str(key))\n                    if str(key) in self.storedList:\n                        branch.setCheckState(0, Qt.Checked)\n                    else:\n                        branch.setCheckState(0, Qt.Unchecked)\n\n                    self.leaves.append(branch)\n\n        def hiddenChildCheck(self, item):\n            if item:\n                children = \[item.child(i) for i in range(item.childCount())]\n                allChildHidden = True\n\n                for c in children:\n                    if not c.isHidden():\n                        allChildHidden = False\n\n                item.setHidden(allChildHidden)\n                if allChildHidden:\n                    self.hiddenChildCheck(item.parent())\n\n        def filterTree(self):\n            self.node.knob(\"search\").setValue(self.filter.text())\n            allItem = self.getAllItem()\n            for item in allItem:\n                item.setHidden(False)\n            if self.filter.text():\n                filter = self.filter.text().lower()\n\n                parent = \[]\n                for leaf in self.leaves:\n                    if filter in leaf.toolTip(0).lower():\n                        leaf.setHidden(False)\n                    else:\n                        leaf.setHidden(True)\n                        parent.append(leaf.parent())\n                for p in set(parent):\n                    self.hiddenChildCheck(p)\n\n        def fillTree(self):\n            self.treeWidget.clear()\n            try:\n                self.treeWidget.itemChanged.disconnect()\n            except:\n                pass\n\n            for k in sorted(self.cryptoInfo.tree.keys()):\n                if k == self.currentLayer:\n                    self.leaves = \[]\n                    self.buildBranch(self.cryptoInfo.tree\[k], self.treeWidget)\n\n            self.filterTree()\n            self.treeWidget.itemChanged.connect(self.handleItemChanged)\n            self.handleItemChanged(None, None)\n\n        def getBranch(self, branch):\n            \"\"\"Returns all QTreeWidgetItems in the subtree rooted at the given node.\"\"\"\n            nodes = \[]\n            nodes.append(branch)\n            for i in range(branch.childCount()):\n                nodes.extend(self.getBranch(branch.child(i)))\n            return nodes\n\n        def getAllItem(self):\n            \"\"\"Returns all QTreeWidgetItems in the given QTreeWidget.\"\"\"\n            allItem = \[]\n            for i in range(self.treeWidget.topLevelItemCount()):\n                topItem = self.treeWidget.topLevelItem(i)\n                allItem.extend(self.getBranch(topItem))\n            return allItem\n\n        def find_checked(self):\n            checkedShapes = \[str(item.toolTip(0)) for item in self.leaves if\n                             (item.checkState(0) == Qt.Checked) and item.toolTip(0)]\n            return checkedShapes\n\n        def previewMatte(self, shapes, channel):\n            exp = self.cryptoInfo.buildCryptoExpression(shapes, channel)\n            with self.node:\n                previewExpression = nuke.toNode(\"PreviewExp\")\n                previewExpression\[\"expr0\"].setValue(exp)\n\n        def handleItemChanged(self, item, column):\n            if item:\n                try:\n                    self.treeWidget.itemChanged.disconnect()\n                except:\n                    pass\n\n                selected = set(self.treeWidget.selectedItems())\n                if item in selected:\n                    if item.checkState(column) in (Qt.Checked, Qt.Unchecked):\n                        for s in selected:\n                            s.setCheckState(0, item.checkState(column))\n\n                self.treeWidget.itemChanged.connect(self.handleItemChanged)\n\n            if self.currentLayer:\n                self.storedList = self.find_checked()\n                self.node.knob(\"store\").setValue(str(self.storedList))\n                self.previewMatte(self.storedList, self.currentLayer)\n\n        def getCoordinate(self):\n            bboxinfo = nuke.activeViewer().node()\[\"colour_sample_bbox\"].value()\n            aspect = float(self.node.node(\"Cryptomatte\").width()) / float(self.node.node(\"Cryptomatte\").height())\n            coordinate = \[\n                (bboxinfo\[0] * 0.5 + 0.5) * self.node.node(\"Cryptomatte\").width(),\n                (((bboxinfo\[1] * 0.5) + (0.5 / aspect)) * aspect) * self.node.node(\"Cryptomatte\").height()\n            ]\n            return coordinate\n\n        def eventFilter(self, obj, event):\n            if self.pickState:\n                if event.type() in \[QEvent.Type.HoverMove, QEvent.Type.UpdateRequest]:\n                    pos = QCursor.pos()\n                    currentPos = self.getCoordinate()\n                    if self.pickPosition != currentPos:\n                        self.pickPosition = currentPos\n                        if self.ctrlPress and self.altPress:\n                            name = self.cryptoInfo.getName(self.pickPosition\[0], self.pickPosition\[1],\n                                                           self.currentLayer)\n                            for leaf in self.leaves:\n                                if leaf.toolTip(0) == name:\n                                    leaf.setCheckState(0, Qt.Unchecked)\n                            self.handleItemChanged(None, None)\n                        elif self.ctrlPress:\n                            name = self.cryptoInfo.getName(self.pickPosition\[0], self.pickPosition\[1],\n                                                           self.currentLayer)\n                            for leaf in self.leaves:\n                                if leaf.toolTip(0) == name:\n                                    leaf.setCheckState(0, Qt.Checked)\n                            self.handleItemChanged(None, None)\n\n                elif event.type() == QEvent.Type.KeyPress:\n                    if event.key() == Qt.Key_Control:\n                        self.ctrlPress = True\n                    elif event.key() == Qt.Key_Alt:\n                        self.altPress = True\n\n                elif event.type() == QEvent.Type.KeyRelease:\n                    if event.key() == Qt.Key_Control:\n                        self.ctrlPress = False\n                    elif event.key() == Qt.Key_Alt:\n                        self.altPress = False\n\n            return QObject.eventFilter(obj, obj, event)\n\n        def pickScreen(self):\n            self.pickState = self.pick.isChecked()\n\n        def toggle(self, state):\n            try:\n                self.treeWidget.itemChanged.disconnect()\n            except:\n                pass\n\n            for item in self.leaves:\n                if not item.isHidden() and item.toolTip(0):\n                    if state == \"All\":\n                        item.setCheckState(0, Qt.Checked)\n                    elif state == \"None\":\n                        item.setCheckState(0, Qt.Unchecked)\n                    elif state == \"Invert\":\n                        if item.checkState(0) == Qt.Checked:\n                            item.setCheckState(0, Qt.Unchecked)\n                        elif item.checkState(0) == Qt.Unchecked:\n                            item.setCheckState(0, Qt.Checked)\n\n            self.treeWidget.itemChanged.connect(self.handleItemChanged)\n            self.handleItemChanged(None, None)\n\n        def storeName(self):\n            self.node.knob(\"matte\").setValue(self.matteName.text())\n\n        def createBtnClicked(self):\n            if self.matteName.text() and self.storedList:\n                for n in self.node.selectedNodes():\n                    n.setSelected(False)\n                matteName = \"_\" + self.matteName.text()\n                exp = self.cryptoInfo.buildCryptoExpression(self.storedList, self.currentLayer)\n                with self.node:\n                    nuke.Layer(matteName, \[matteName + \".a\"])\n\n                    cryptoNode = nuke.toNode(\"PreviewExp\")\n                    cryptoNodePosX = cryptoNode\[\"xpos\"].getValue()\n                    cryptoNodeInput = cryptoNode.input(0)\n\n                    merge = nuke.toNode(\"PreviewMerge\")\n                    mergePosX = merge\[\"xpos\"].getValue()\n                    mergePosY = merge\[\"ypos\"].getValue()\n                    mergeInput = merge.input(0)\n\n                    expNode = nuke.createNode(\"Expression\", \"name \{n\}_exp xpos \{x\} ypos \{y\}\".format(\n                        n=matteName, x=mergePosX - 110, y=mergePosY + 6\n                    ), inpanel=False)\n                    expNode.setInput(0, cryptoNodeInput)\n                    expNode\[\"expr0\"].setValue(exp)\n                    expNode\[\"xpos\"].setValue(mergePosX - 110)\n                    expNode\[\"ypos\"].setValue(mergePosY + 6)\n\n                    copyNode = nuke.createNode(\"Copy\", \"name \{n\}_copy xpos \{x\} ypos \{y\}\".format(\n                        n=matteName, x=mergePosX, y=mergePosY\n                    ), inpanel=False)\n                    copyNode\[\"from0\"].setValue(\"rgba.red\")\n                    copyNode\[\"to0\"].setValue(matteName + \".a\")\n                    copyNode.setInput(0, mergeInput)\n                    copyNode.setInput(1, expNode)\n\n                    expNode.setSelected(False)\n                    copyNode.setSelected(False)\n\n                    cryptoNode\[\"ypos\"].setValue(mergePosY + 50)\n                    cryptoNode.setInput(0, cryptoNodeInput)\n                    merge\[\"ypos\"].setValue(mergePosY + 50)\n                    merge.setInput(0, copyNode)\n                    merge.setInput(1, cryptoNode)\n\n                    outputNode = nuke.toNode(\"Output\")\n                    outputNodePosY = outputNode\[\"ypos\"].getValue()\n                    outputNode\[\"ypos\"].setValue(outputNodePosY + 50)\n                    outputNode.setInput(0, merge)\n\n                for item in self.leaves:\n                    item.setCheckState(0, Qt.Unchecked)\n\n                self.matteName.setText(\"\")\n            elif self.storedList:\n                nuke.message(\"Please provided matte name\")\n            elif self.matteName.text():\n                nuke.message(\"Please select at least one matte \")\n            else:\n                nuke.message(\"Please select at least one matte and provide matte name\")\n\n        def updateValue(self):\n            pass\n\n\nclass installCryptoList:\n    def __init__(self):\n        self.instance = 0\n        return None\n\n    def makeUI(self):\n        self.instance = cryptoList(nuke.thisNode())\n        try:\n            nukeApp.removeEventFilter(self.instance)\n        except:\n            pass\n\n        nukeApp.installEventFilter(self.instance)\n\n        return self.instance\n\n    def updateInfo(self):\n        if self.instance:\n            self.instance.initCrypto()\n\n\nlaunched = 1\n" +STARTLINE}
 addUserKnob {52 initCryptoFunction T "nuke.thisNode().knob(\"cryptoFunction\").execute()" +STARTLINE}
 addUserKnob {52 cryptoPanel l "" t "Cryptomatte Matte Creator" +STARTLINE T installCryptoList() +STARTLINE}
 addUserKnob {1 channel l INVISIBLE +INVISIBLE}
 addUserKnob {1 search l INVISIBLE +INVISIBLE}
 addUserKnob {1 matte l INVISIBLE +INVISIBLE}
 addUserKnob {1 store l INVISIBLE +INVISIBLE}
 store "\[]"
}
 Input {
  inputs 0
  name Cryptomatte
  selected true
  xpos -274
  ypos 137
  number 1
 }
 Remove {
  channels rgba
  name Remove_RGBA
  selected true
  xpos -274
  ypos 163
 }
set N1cd33630 [stack 0]
 Expression {
  channel0 {rgba.red -rgba.green -rgba.blue rgba.alpha}
  name PreviewExp
  selected true
  xpos -274
  ypos 187
 }
 Input {
  inputs 0
  name Image
  selected true
  xpos -54
  ypos 137
 }
push $N1cd33630
push $N1cd33630
add_layer {CryptoMaterial CryptoMaterial.red CryptoMaterial.green CryptoMaterial.blue CryptoMaterial.alpha}
 ShuffleCopy {
  inputs 2
  in CryptoMaterial
  red red
  green green
  blue blue
  alpha black
  name NoInput
  selected true
  xpos -164
  ypos 163
 }
 Switch {
  inputs 2
  which {{"\[exists parent.input0]"}}
  name InputCheck
  selected true
  xpos -54
  ypos 163
 }
 Merge2 {
  inputs 2
  name PreviewMerge
  selected true
  xpos -54
  ypos 187
 }
 Output {
  name Output
  selected true
  xpos -54
  ypos 213
 }
end_group
